<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis存储系统 | 风雨欲来兮丶</title><meta name="author" content="SeanXia"><meta name="copyright" content="SeanXia"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Redis是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。拥有丰富的支持主流语言的客户端，C、C++、Python、Erlang、R、C#、Java、PHP、ObjectiveC、Perl、Ruby、Scala、Go、JavaScript。">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis存储系统">
<meta property="og:url" content="http://www.seanxia.cn/%E5%A4%A7%E6%95%B0%E6%8D%AE/890ab287.html">
<meta property="og:site_name" content="风雨欲来兮丶">
<meta property="og:description" content="Redis是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。拥有丰富的支持主流语言的客户端，C、C++、Python、Erlang、R、C#、Java、PHP、ObjectiveC、Perl、Ruby、Scala、Go、JavaScript。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://seanxia.oss-cn-shanghai.aliyuncs.com/img/hexo/headpic.jpg">
<meta property="article:published_time" content="2017-10-13T16:00:00.000Z">
<meta property="article:modified_time" content="2019-08-10T13:45:00.000Z">
<meta property="article:author" content="SeanXia">
<meta property="article:tag" content="内存">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://seanxia.oss-cn-shanghai.aliyuncs.com/img/hexo/headpic.jpg"><link rel="shortcut icon" href="https://seanxia.oss-cn-shanghai.aliyuncs.com/img/hexo/LOGO%E9%80%8F%E6%98%8E.png"><link rel="canonical" href="http://www.seanxia.cn/%E5%A4%A7%E6%95%B0%E6%8D%AE/890ab287.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: SeanXia","link":"链接: ","source":"来源: 风雨欲来兮丶","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis存储系统',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2019-08-10 21:45:00'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="风雨欲来兮丶" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://seanxia.oss-cn-shanghai.aliyuncs.com/img/hexo/headpic.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">43</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">72</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友联</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://seanxia.oss-cn-shanghai.aliyuncs.com/img/hexo/butterfly.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="风雨欲来兮丶"><span class="site-name">风雨欲来兮丶</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友联</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Redis存储系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2017-10-13T16:00:00.000Z" title="发表于 2017-10-14 00:00:00">2017-10-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2019-08-10T13:45:00.000Z" title="更新于 2019-08-10 21:45:00">2019-08-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>37分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id data-flag-title="Redis存储系统"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/%E5%A4%A7%E6%95%B0%E6%8D%AE/890ab287.html#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>Redis是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。拥有丰富的支持主流语言的客户端，C、C++、Python、Erlang、R、C#、Java、PHP、ObjectiveC、Perl、Ruby、Scala、Go、JavaScript。</p>
<span id="more"></span>
<h2 id="Redis的特点">Redis的特点</h2>
<p><strong>1、数据结构丰富</strong></p>
<p>Redis 虽然也是<code>键值对</code>数据库，但是和 Memcached 不同的是，Redis 的<code>值</code>支持多种类型的数据结构，不仅可以是字符串，同时还提供散列（hash），列表（list），集合（sets），有序集合（sorted sets）等数据结构。</p>
<p>通过选用不同的数据结构，用户可以使用 Redis 解决各式各样的问题。</p>
<p><img src="https://seanxia.oss-cn-shanghai.aliyuncs.com/img/hexo/7308598bgy1g065mjrg0dj20eu09g3za.jpg" alt></p>
<p><strong>数据库有两种，一种硬盘数据库，一种内存数据库。</strong></p>
<p>硬盘是把值储存在硬盘，典型的是 SQL 数据库。在内存里面就存储一下索引，当硬盘数据库想访问硬盘的值<br>
时，它先在内存里面找到索引，然后在找值，问题是什么，在读取和写入硬盘的时候，如果读写比较多的时候，它会把硬盘 IO 堵死。</p>
<p><img src="https://seanxia.oss-cn-shanghai.aliyuncs.com/img/hexo/7308598bgy1g065mt989yj20ed0atdhx.jpg" alt></p>
<p>至于内存数据库，它会直接把值放到内存里面，内存数据库就直接把值取到，风一样的感觉，读写数据的时候都不会受到硬盘 IO 速度的限制，所以速度极快。</p>
<p><img src="https://seanxia.oss-cn-shanghai.aliyuncs.com/img/hexo/7308598bgy1g065ratbb8j20fi0a60u3.jpg" alt></p>
<p><strong>2、数据的持久化</strong></p>
<p>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</p>
<p><strong>3、数据的备份</strong></p>
<p>Redis 支持数据的备份，即 master-slave 模式的数据备份。</p>
<h2 id="Redis的安装">Redis的安装</h2>
<p>下载安装包，redis-3.2.9.tar.gz 网址：<a href="http://www.redis.cn/download.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.redis.cn/download.html</a></p>
<p><strong>第一步：依赖软件安装 yum -y install gcc tcl -y</strong></p>
<p><img src="https://seanxia.oss-cn-shanghai.aliyuncs.com/img/hexo/7308598bgy1g065tstqd4j20ay03qaau.jpg" alt></p>
<p><strong>第二步： 进入解压 redis 的文件夹</strong></p>
<p><img src="https://seanxia.oss-cn-shanghai.aliyuncs.com/img/hexo/7308598bgy1g065tzmdk4j20cg02iaaq.jpg" alt></p>
<p><strong>第三步： 执行 mkae 命令</strong></p>
<p><strong>第四步： 执行 make install</strong></p>
<p><strong>第五步： 修改 redis 的配置文件 redis.config ( 先备份一个原厂配置文件)</strong></p>
<p><img src="https://seanxia.oss-cn-shanghai.aliyuncs.com/img/hexo/7308598bgy1g065ugosj7j20d201rq3d.jpg" alt></p>
<p>进入 myredis 文件中修改运行模式为后台运行，daemonize 修改成 yes</p>
<p><strong>第六步：启动 redis 服务器，使用修改后配置文件的位置</strong></p>
<p>命令： redis-server 配置文件的地址</p>
<p><img src="https://seanxia.oss-cn-shanghai.aliyuncs.com/img/hexo/7308598bgy1g065vpt9aej20fe04lq4v.jpg" alt></p>
<blockquote>
<p>如果修改 redis.conf，采用 redis 默认的 redis.conf 文件，redis 默认只能通过 127.0.0.1:6379 这个地址访问，这样就只能在本机上操作了，如果想要远程操作就不可行了。</p>
</blockquote>
<p>这里需要修改 redis.conf 这个配置文件，在配置文件中添加相应的 ip 地址，这里假如添加 ip 地址：192.168.110.4，只需在 redis.conf 这个配置文件中 bind 127.0.0.1 后面追加：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bind</span> 127.0.0.1 192.168.110.4</span><br></pre></td></tr></table></figure>
<p><img src="https://seanxia.oss-cn-shanghai.aliyuncs.com/img/hexo/7308598bgy1g06949gr26j20h2060jrf.jpg" alt></p>
<p><strong>第七步：客户端连接：在命令行 输入 cd /usr/local/bin</strong></p>
<p>进入这个目录 命令行输入： ./redis-cli</p>
<p><img src="https://seanxia.oss-cn-shanghai.aliyuncs.com/img/hexo/7308598bgy1g065yofhvhj20eq01haan.jpg" alt></p>
<p><img src="https://seanxia.oss-cn-shanghai.aliyuncs.com/img/hexo/7308598bgy1g065yxiie6j20ff01rmy3.jpg" alt></p>
<p>客户端命令格式：redis-cli –h host –p port</p>
<h2 id="Redis的使用">Redis的使用</h2>
<p>Redis key 值是二进制安全的，这意味着可以用任何二进制序列作为 key值，从形如”foo”的简单字符串到一个 JPEG 文件的内容都可以。空字符串也是有效 key 值。</p>
<h3 id="切换数据库">切换数据库</h3>
<p>select databaseid 默认共有 16 个实例库，登录时是 ID 为 0 的数据库，总共有 16 个</p>
<p><img src="https://seanxia.oss-cn-shanghai.aliyuncs.com/img/hexo/7308598bgy1g0663n0pbgj20cu03zgli.jpg" alt></p>
<h3 id="Key操作">Key操作</h3>
<p><strong>keys pattern</strong></p>
<p>查找所有符合给定模式 pattern 的 key 。</p>
<p><strong>exists  key</strong></p>
<p>检查给定 key 是否存在。</p>
<p><strong>expire key seconds</strong></p>
<p>为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删除。</p>
<p><strong>move key db</strong></p>
<p>将当前数据库的 key 移动到给定的数据库 db 当中。如果当前数据库(源数据库)和给定数据库(目标数据库)有相同名字的给定 key ，或者 key 不存在于当前数据库，那么 MOVE 没有任何效果。</p>
<p><strong>ttl key</strong></p>
<p>以秒为单位，返回给定 key 的剩余生存时间</p>
<p><strong>type key</strong></p>
<p>返回 key 所储存的值的类型。</p>
<p><strong>del key [key …]</strong></p>
<p>删除给定的一个或多个 key 。不存在的 key 会被忽略。</p>
<h3 id="String操作">String操作</h3>
<p>字符串是一种最基本的 Redis 值类型。Redis 字符串是二进制安全的，这意味着一个 Redis 字符串能包含任意类型的数据。</p>
<p><strong>set key value [EX seconds] [PX milliseconds] [NX|XX]</strong></p>
<ul>
<li>EX 设置过期时间，秒，等同于 SETEX key seconds value</li>
<li>PX 设置过期时间，毫秒，等同于 PSETEX key milliseconds value</li>
<li>NX 键不存在，才能设置，等同于 SETNX key value</li>
<li>XX 键存在时，才能设置</li>
</ul>
<p>将字符串值 value 关联到 key 。</p>
<p>如果 key 已经持有其他值， SET 就覆写旧值，无视类型。</p>
<p>对于某个原本带有生存时间（TTL）的键来说， 当 SET 命令成功在这个键上执行时， 这个键原有的 TTL 将被清除。</p>
<p><strong>get key</strong></p>
<p>返回 key 所关联的字符串值。如果 key 不存在那么返回特殊值 nil 。</p>
<p>假如 key 储存的值不是字符串类型，返回一个错误，因为 GET 只能用于处理字符串值。</p>
<p><strong>append key value</strong></p>
<p>如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾。</p>
<p>如果 key 不存在， APPEND 就简单地将给定 key 设为 value ，就像执行 SET key value 一样。</p>
<p><strong>strlen key</strong></p>
<p>返回 key 所储存的字符串值的长度。</p>
<p>当 key 储存的不是字符串值时，返回一个错误。</p>
<p><strong>incr key</strong></p>
<p>将 key 中储存的数字值增一。</p>
<p>如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行INCR 操作。</p>
<p>如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。</p>
<p><strong>incrby key increment</strong></p>
<p>将 key 所储存的值加上增量 increment 。</p>
<p>如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行INCRBY 命令。</p>
<p>如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。</p>
<p><strong>decr key</strong></p>
<p>将 key 中储存的数字值减一。</p>
<p><strong>decrby key decrement</strong></p>
<p>将 key 所储存的值减去减量 decrement 。</p>
<p><strong>getrange key start end</strong></p>
<p>返回 key 中字符串值的子字符串。</p>
<p>字符串的截取范围由 start 和end 两个偏移量决定(包括 start 和 end 在内)。</p>
<p>负数偏移量表示从字符串最后开始计数， -1 表示最后一个字符， -2 表示倒数第二个，以此类推。</p>
<p><strong>setrange key offset value</strong></p>
<p>用 value 参数覆写(overwrite)给定 key 所储存的字符串值，从偏移量 offset 开始。</p>
<p>不存在的 key 当作空白字符串处理。</p>
<p><strong>setex key  seconds value</strong></p>
<p>将值 value 关联到 key ，并将 key 的生存时间设为 seconds。</p>
<p>如果 key 已经存在， SETEX 命令将覆写旧值。</p>
<p>这个命令类似于以下两个命令：SET key value</p>
<p><strong>expire key seconds</strong> # 设置生存时间</p>
<p>不同之处是， SETEX 是一个原子性(atomic)操作，关联值和设置生存时间两个动作会在同一时间内完成，该命令在 Redis 用作缓存时，非常实用。</p>
<p><strong>setnx key value</strong></p>
<p>将 key 的值设为 value ，当且仅当 key 不存在。</p>
<p>若给定的 key 已经存在，则 SETNX 不做任何动作。</p>
<p>SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p>
<p><strong>mget key [key …]</strong></p>
<p>返回所有(一个或多个)给定 key 的值。</p>
<p>如果给定的 key 里面，有某个 key 不存在，那么这个 key 返回特殊值 nil 。因此，该命令永不失败。</p>
<p><strong>mset key value [key value …]</strong></p>
<p>同时设置一个或多个 key-value 对。</p>
<p>如果某个给定 key 已经存在，那么 MSET 会用新值覆盖原来的旧值，如果这不是你所希望的效果，请考虑使用 MSETNX 命令：它只会在所有给定 key 都不存在的情况下进行设置操作。</p>
<p><strong>msetnx key value [key value …]</strong></p>
<p>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</p>
<p>即使只有一个给定 key 已存在， MSETNX 也会拒绝执行所有给定 key 的设置操作。</p>
<p>MSETNX 是原子性的，因此它可以用作设置多个不同 key 表示不同字段(field)的唯一性逻辑对象(unique logic object)，所有字段要么全被设置，要么全不被设置。</p>
<h3 id="List操作">List操作</h3>
<p><strong>lpush key value [value …]</strong></p>
<p>将一个或多个值 value 插入到列表 key 的表头</p>
<p>如果有多个 value 值，那么各个 value 值按从左到右的顺序依次插入到表头 ： 比如说 ， 对空列表 mylist 执行命令 LPUSH mylist a b c ，列表的值将是 c b a ，这等同于原子性地 执行 LPUSH mylist a 、 LPUSH mylist b 和 LPUSH mylist c 三个命令。</p>
<p><strong>rpush key value [value …]</strong></p>
<p>将一个或多个值 value 插入到列表 key 的表尾(最右边)。</p>
<p>如果有多个 value 值，那么各个 value 值按从左到右的顺序依次插入到表尾 ： 比如对一个空列表 mylist  执行 RPUSH mylist a b c ，得出的结果列表为 a b c ，等同于执行命令 RPUSH mylist a 、 RPUSH mylist b 、 RPUSH mylist c 。</p>
<p><strong>lrange key  start stop</strong></p>
<p>返回列表 key 中指定区间内的元素，区间以偏移量 start 和 stop 指定。</p>
<p>下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。</p>
<p><strong>lpop key</strong></p>
<p>移除并返回列表 key 的头元素。</p>
<p><strong>rpop key</strong></p>
<p>移除并返回列表 key 的尾元素。</p>
<p><strong>lindex key index</strong></p>
<p>返回列表 key 中，下标为 index 的元素。</p>
<p>下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。</p>
<p>你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</p>
<p><strong>llen key</strong></p>
<p>返回列表 key 的长度。</p>
<p>如果 key 不存在，则 key 被解释为一个空列表，返回 0 .</p>
<p><strong>lrem key count value</strong></p>
<p>根据参数 count 的值，移除列表中与参数 value 相等的元素。<br>
count 的值可以是以下几种：</p>
<p>count &gt; 0 : 从表头开始向表尾搜索，移除与 value 相等的元素，数量为 count 。</p>
<p>count &lt; 0 : 从表尾开始向表头搜索，移除与 value 相等的元素，数量为 count 的绝对值。</p>
<p>count = 0 : 移除表中所有与 value 相等的值。</p>
<p><strong>ltrim key start stop</strong></p>
<p>对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</p>
<p>举个例子 ， 执行命令 LTRIM list 0 2 ， 表示只保留列表 list 的前三个元素，其余元素全部删除。</p>
<p><strong>rpoplpush source  destination</strong></p>
<p>命令 RPOPLPUSH 在一个原子时间内，执行以下两个动作：</p>
<p>将列表 source 中的最后一个元素(尾元素)弹出，并返回给客户端。</p>
<p>将 source  弹出的元素插入到列表 destination，作为 destination 列表的的头元素。<br>
举个例子，你有两个列表 source  和 destination，source 列表有元素 a, b, c ， destination 列表有元素 x, y, z ，执行 RPOPLPUSH sourcedestination 之后，source 列表包含元素 a, b ， destination 列表包含元素 c, x, y, z ，并且元素 c 会被返回给客户端。</p>
<p><strong>lset key index value</strong></p>
<p>将列表 key 下标为 index 的元素的值设置为 value 。</p>
<p>当 index 参数超出范围，或对一个空列表( key 不存在)进行 LSET 时，返回一个错误。</p>
<p><strong>linsert key BEFORE|AFTER pivot value</strong></p>
<p>将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。</p>
<p>当 pivot 不存在于列表 key 时，不执行任何操作。</p>
<p>当 key 不存在时， key 被视为空列表，不执行任何操作。</p>
<h3 id="Set操作">Set操作</h3>
<p><strong>sadd key member [member …]</strong></p>
<p>将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略。</p>
<p>假如 key 不存在，则创建一个只包含 member 元素作成员的集合。</p>
<p><strong>smembers key</strong></p>
<p>返回集合 key 中的所有成员。</p>
<p>不存在的 key 被视为空集合。</p>
<p><strong>sismember key member</strong></p>
<p>判断 member 元素是否集合 key 的成员。</p>
<p><strong>scard key</strong></p>
<p>返回集合 key 的基数(集合中元素的数量)。</p>
<p><strong>srem key member [member …]</strong></p>
<p>移除集合 key 中的一个或多个 member 元素 ， 不存在的 member 元素会被忽略。</p>
<p><strong>spop key （抽奖场景）</strong></p>
<p>移除并返回集合中的一个随机元素。</p>
<p>如果只想获取一个随机元素，但不想该元素从集合中被移除的话，可以使用 SRANDMEMBER 命令。</p>
<p><strong>smove source destination member</strong></p>
<p>将 member 元素从 source 集合移动到 destination 集合。</p>
<p>SMOVE 是原子性操作。</p>
<p>如果 source 集合不存在或不包含指定的 member 元素，则 SMOVE 命令不执行任何操作，仅返回 0 。否则， member 元素从 source 集合中被移除，并添加到 destination 集合中去。</p>
<p>当 destination 集合已经包含 member 元素时，SMOVE命令只是简单地将 source 集合中的 member 元素删除。</p>
<p>当 source 或 destination 不是集合类型时，返回一个错误。</p>
<p><strong>sdiff key [key …]</strong></p>
<p>求差集：从第一个 key 的集合中去除其他集合和自己的交集部分</p>
<p><strong>sinter key [key  …]</strong> （微博求共同关注场景）</p>
<p>返回一个集合的全部成员，该集合是所有给定集合的交集。</p>
<p>不存在的 key 被视为空集。</p>
<p>当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。</p>
<p><strong>sunion key [key …]</strong></p>
<p>返回一个集合的全部成员，该集合是所有给定集合的并集。</p>
<p>不存在的 key 被视为空集。</p>
<h3 id="Sorted-set-操作">Sorted set  操作</h3>
<p>类似 Sets,但是每个字符串元素都关联到一个叫 score 浮动数值。里面的元素总是通过 score 进行着排序，所以不同的是，它是可以检索的一系列元素。注意：在 set 基础上，加上 score 值，之前 set 是key value1 value2….</p>
<p>现在 Zset 是 key score1 value1 score2 value2</p>
<p><strong>zadd key score member [[score member] [score member] …]</strong></p>
<p>将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</p>
<p><strong>zrange key start stop [WITHSCORES]</strong></p>
<p>返回有序集 key 中，指定区间内的成员。</p>
<p>其中成员的位置按 score 值递减(从小到大)来排列。</p>
<p><strong>zrevrange key start stop [WITHSCORES]</strong>( 音乐排行榜场景）</p>
<p>返回有序集 key 中，指定区间内的成员。</p>
<p>其中成员的位置按 score 值递减(从大到小)来排列。</p>
<p><strong>zrem key member [member …]</strong></p>
<p>移除有序集 key 中的一个或多个成员，不存在的成员将被忽略。</p>
<p><strong>zremrangebyscore key min max</strong></p>
<p>移除有序集 key 中，所有 score 值介于 min 和 max 之间，（包括等于 min 或 max）的成员。</p>
<p><strong>zscore key member</strong></p>
<p>返回有序集 key 中，成员 member 的 score 值。</p>
<p><strong>zcard key</strong></p>
<p>返回有序集 key 的基数。</p>
<p><strong>zcount key min max</strong></p>
<p>返回有序集 key 中， score 值在 min 和 max 之间（默认包括 score 值等于 min 或 max）的成员的数量。</p>
<p><strong>zrank key member</strong></p>
<p>返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递增(从小到大)顺序排列。</p>
<h3 id="Hash操作（散列）">Hash操作（散列）</h3>
<p>KV 模式不变，但是 V 是一个键值对。</p>
<p><strong>hset key field value</strong></p>
<p>将哈希表 key 中的域 field 的值设为 value 。</p>
<p><strong>hget key field</strong></p>
<p>返回哈希表 key 中给定域 field 的值。</p>
<p><strong>hmset key field value [field value …]</strong></p>
<p>同时将多个 field-value (域-值)对设置到哈希表 key 中。</p>
<p>此命令会覆盖哈希表中已存在的域。</p>
<p><strong>hmget key field [field …]</strong></p>
<p>返回哈希表 key 中，一个或多个给定域的值。</p>
<p><strong>hgetall key</strong></p>
<p>返回哈希表 key 中，所有的域和值。</p>
<p><strong>hkeys key</strong></p>
<p>返回哈希表 key 中的所有域。</p>
<p><strong>hvals key</strong></p>
<p>返回哈希表 key 中所有域的值。</p>
<p><strong>hsetnx key field value</strong></p>
<p>将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在。</p>
<p>若域 field 已经存在，该操作无效。</p>
<p><strong>hexists key field</strong></p>
<p>查看哈希表 key 中，给定域 field 是否存在。</p>
<p><strong>hdel key field [field …]</strong></p>
<p>删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略。</p>
<p><strong>hincrby key field increment</strong></p>
<p>为哈希表 key 中的域 field 的值加上增量 increment 。</p>
<p>增量也可以为负数，相当于对给定域进行减法操作。</p>
<p><strong>hincrbyfloat key field increment</strong></p>
<p>增加浮点数。</p>
<p><strong>场景：用户维度统计</strong></p>
<p>统计数包括：关注数、粉丝数、喜欢商品数、发帖数</p>
<p>用户为 Key，不同维度为 Field，Value 为统计数。</p>
<h2 id="Redis的持久化">Redis的持久化</h2>
<p>Redis 提供了多种不同级别的持久化方式。</p>
<blockquote>
<ul>
<li>RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。</li>
<li>AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。</li>
<li>Redis 还可以同时使用 AOF 持久化和 RDB 持久化。 在这种情况下， 当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。</li>
<li>你甚至可以关闭持久化功能，让数据只在服务器运行时存在。</li>
</ul>
</blockquote>
<h3 id="RDB-Redis-DataBase">RDB(Redis DataBase)</h3>
<p>Rdb：在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的 snapshot <strong>快照</strong>，它恢复时就是将快照文件直接读到内存里。</p>
<p><code>Redis 会单独的创建(fork) 一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程结束了，再用这个临时文件替换上次持久化的文件</code>。整个过程中，主进程是不进行任何 IO 操作，这就确保了极高的性能，如果需要进行大规模的数据恢复，且对于数据恢复的完整性不是非常敏感，那 RDB 方法要比 AOF 方式更加的高效。RDB 的缺点是最后一次持久化后的数据可能丢失。</p>
<blockquote>
<p>Fork 的作用是复制一个与当前进程一样的进程，新进程的所有数据(变量、环境变量、程序计数器等)数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。</p>
</blockquote>
<p><strong>Rdb 保存的是 dump.rdb 文件</strong></p>
<p><img src="https://seanxia.oss-cn-shanghai.aliyuncs.com/img/hexo/7308598bgy1g067jrf76tj20d105gjub.jpg" alt></p>
<p><strong>RDB save 操作</strong></p>
<p>Rdb 是整个内存的压缩的 snapshot，RDB 的数据结构，可以配置符合快照触发条件，默认的是 1 分钟内改动 1 万次，或者 5 分钟改动 10 次，或者是 15 分钟改动一次。</p>
<p>Save 禁用：如果想禁用 RDB 持久化的策略，只要不设置任何save 指令，或者是给 save 传入一个空字符串参数也可以。</p>
<p><img src="https://seanxia.oss-cn-shanghai.aliyuncs.com/img/hexo/7308598bgy1g067kos9fnj205101dmx3.jpg" alt></p>
<p>save 指令：即刻保存操作对象</p>
<p><strong>手动触发 RDB  快照</strong></p>
<p><code>Save：</code>save 时只管保存，其他不管，全部阻塞。</p>
<p><code>Bgsave：</code>redis 会在后台进行快照操作，快照操作的同时还可以响应客户端的请求，可以通过 lastsave 命令获取最后一次成功执行快照的时间。</p>
<p><strong>如何停止</strong></p>
<p>静态停止：将配置文件里的 RDB 保存规则改为 save “”</p>
<p>动态停止 ：</p>
<p><img src="https://seanxia.oss-cn-shanghai.aliyuncs.com/img/hexo/7308598bgy1g067mezciaj20e501wq2w.jpg" alt></p>
<h3 id="AOF-Append-Only-File">AOF(Append Only File)</h3>
<p>以日志的形式来记录每个写操作，将 redis 执行过的所有写指令记录下来(读操作不记录)。只许追加文件但不可以改写文件，redis 启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次完成数据恢复工作。</p>
<p>=== APPEND ONLY MODE ==<br>
开启 aof ：appendonly yes (默认是 no)</p>
<p><img src="https://seanxia.oss-cn-shanghai.aliyuncs.com/img/hexo/7308598bgy1g067np9syfj20bt03gmyq.jpg" alt></p>
<p><strong>AOF 策略</strong></p>
<p><img src="https://seanxia.oss-cn-shanghai.aliyuncs.com/img/hexo/7308598bgy1g067o5amz7j207m030mxp.jpg" alt></p>
<p>Appendfsync 参数：</p>
<p>**Always： **每次发生数据变更会被立即记录到磁盘，性能较差但数据完整性较好。</p>
<p><strong>Everysec：</strong> 出厂默认推荐，异步操作，每秒记录，不到一秒宕机，有数据丢失</p>
<p>**No：**从不 fsync ，将数据交给操作系统来处理。更快，也更不安全的选择。因为操作系统只会等内存满了才会溢写，如果没满宕机，数据就会丢失。</p>
<p><strong>Rewrite</strong>概念：AOF 采用文件追加方式，文件会越来越来大为避免出现此种情况，新增了重写机制，aof 文件的大小超过所设定的阈值时，redis 就会自动 aof 文件的内容压缩，只保留可以恢复数据的最小指令集，可以使用命令 bgrewirteaof。</p>
<blockquote>
<p>**重写原理：**aof 文件持续增长而大时，会 fork 出一条新进程来将文件重写(也就是先写临时文件最后再 rename)，遍历新进程的内存中的数据，每条记录有一条 set 语句，重写 aof 文件的操作，并没有读取旧的的 aof 文件，而是将整个内存的数据库内容用命令的方式重写了一个新的 aof 文件，这点和快照有点类似。<br>
**触发机制：**redis 会记录上次重写的 aof 的大小，默认的配置当 aof 文件为上次 rewrite 后大小的一倍且文件大于 64M 触发。</p>
</blockquote>
<p><img src="https://seanxia.oss-cn-shanghai.aliyuncs.com/img/hexo/7308598bgy1g067qylpyoj20ce02ndgc.jpg" alt></p>
<p><strong>no-appendfsync-on-rewrite no :</strong> 重写时是否可以运用 Appendfsync 用默认no 即可，保证数据安全</p>
<p><strong>auto-aof-rewrite-percentage：</strong> 倍数 设置基准值</p>
<p><strong>auto-aof-rewrite-min-size：</strong>  设置基准值大小</p>
<p><strong>AOF 优点</strong></p>
<p>使用 AOF 持久化会让 Redis 变得非常耐久：你可以设置不同的 fsync 策略，比如无 fsync ，每秒钟一次 fsync ，或者每次执行写入命令时 fsync 。AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（ fsync 会在后台线程执行，所以主线程可以继续努力地处理命令请求）。</p>
<p>AOF 文件是一个只进行追加操作的日志文件（append only log）， 因此对AOF 文件的写入不需要进行 seek ， 即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机，等），redis-check-aof 工具也可以轻易地修复这种问题。</p>
<p>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。</p>
<p>AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写，那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态。</p>
<p><strong>AOF  缺点</strong></p>
<p>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。</p>
<p>根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。</p>
<p><strong>备份 Redis  数据</strong></p>
<p>一定要备份你的数据库！</p>
<p>磁盘故障， 节点失效， 诸如此类的问题都可能让你的数据消失不见， 不进行备份是非常危险的。</p>
<p>Redis 对于数据备份是非常友好的， 因为你可以在服务器运行的时候对RDB 文件进行复制： RDB 文件一旦被创建， 就不会进行任何修改。 当服务器要创建一个新的 RDB 文件时， 它先将文件的内容保存在一个临时文件里<br>
面， 当临时文件写入完毕时， 程序才使用 rename(2) 原子地用临时文件替换原来的 RDB 文件。</p>
<p>这也就是说， 无论何时， 复制 RDB 文件都是绝对安全的。</p>
<p><strong>建议：</strong></p>
<p>创建一个定期任务（cron job）， 每小时将一个 RDB 文件备份到一个文件夹， 并且每天将一个 RDB 文件备份到另一个文件夹。确保快照的备份都带有相应的日期和时间信息， 每次执行定期任务脚本时， 使用 find 命令来删除过期的快照： 比如说， 你可以保留最近 48 小时内的每小时快照， 还可以保留最近一两个月的每日快照。</p>
<p>至少每天一次， 将 RDB 备份到你的数据中心之外， 或者至少是备份到你运行 Redis 服务器的物理机器之外。</p>
<h2 id="Redis主从复制">Redis主从复制</h2>
<p>Redis 支持简单且易用的主从复制（master-slave replication）功能， 该功能可以让从服务器(slave server)成为主服务器(masterserver)的精确复制品 。</p>
<p>以下是关于 Redis 复制功能的几个重要方面：</p>
<ul>
<li>
<p>Redis 使用异步复制。 从 Redis 2.8 开始， 从服务器会以每秒一次的频率向主服务器报告复制流（replication stream）的处理进度。</p>
</li>
<li>
<p>一个主服务器可以有多个从服务器。</p>
</li>
<li>
<p>不仅主服务器可以有从服务器， 从服务器也可以有自己的从服务器，多个从服务器之间可以构成一个图状结构。</p>
</li>
<li>
<p>复制功能不会阻塞主服务器： 即使有一个或多个从服务器正在进行初次同步， 主服务器也可以继续处理命令请求。</p>
</li>
<li>
<p>复制功能也不会阻塞从服务器： 只要在 redis.conf 文件中进行了相应的设置， 即使从服务器正在进行初次同步， 服务器也可以使用旧版本的数据集来处理命令查询。<br>
不过， 在从服务器删除旧版本数据集并载入新版本数据集的那段时间内， 连接请求会被阻塞。</p>
<p>你还可以配置从服务器， 让它在与主服务器之间的连接断开时， 向客户端发送一个错误。</p>
<p>复制功能可以单纯地用于数据冗余（data redundancy）， 也可以通过让多个从服务器处理只读命令请求来提升扩展性（scalability）： 比如说， 繁重的 SORT 命令可以交给附属节点去运行。</p>
</li>
</ul>
<p><strong>从服务器配置</strong></p>
<p>配置一个从服务器非常简单， 只要在配置文件中增加以下的这一行就可以了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">slaveof 192.168.110.4 6379</span><br></pre></td></tr></table></figure>
<p>另外一种方法是调用 SLAVEOF 命令，输入主服务器的 IP 和端口，然后同步就会开始</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SLAVEOF 192.168.110.4 6379</span><br></pre></td></tr></table></figure>
<p><strong>只读从服务器</strong></p>
<p>从 Redis 2.6 开始， 从服务器支持只读模式， 并且该模式为从服务器的默认模式。</p>
<ul>
<li>只读模式由 redis.conf 文件中的 slave-read-only 选项控制， 也可以通过 CONFIG SET 命令来开启或关闭这个模式。</li>
<li>只读从服务器会拒绝执行任何写命令， 所以不会出现因为操作失误而将数据不小心写入到了从服务器的情况。</li>
<li>另外，对一个从属服务器执行命令 SLAVEOF NO ONE 将使得这个从属服务器关闭复制功能，并从从属服务器转变回主服务器，原来同步所得的数据集不会被丢弃。</li>
<li>利用『 SLAVEOF NO ONE 不会丢弃同步所得数据集』这个特性，可以在主服务器失败的时候，将从属服务器用作新的主服务器，从而实现无间断运行。</li>
</ul>
<p><strong>从服务器相关配置：</strong></p>
<p>如果主服务器通过 requirepass 选项设置了密码， 那么为了让从服务器的同步操作可以顺利进行， 我们也必须为从服务器进行相应的身份验证设置。</p>
<p>对于一个正在运行的服务器， 可以使用客户端输入以下命令：</p>
<p>config set masterauth &lt; password &gt;</p>
<p>要永久地设置这个密码， 那么可以将它加入到配置文件中：</p>
<p>masterauth &lt; password &gt;</p>
<p><strong>主服务器只在有至少 N  个从服务器的情况下，才执行写操作</strong></p>
<p>从 Redis 2.8 开始， 为了保证数据的安全性，可以通过配置， 让主服务器只在有至少 N 个当前已连接从服务器的情况下， 才执行写命令。</p>
<p>不过， 因为 Redis 使用异步复制， 所以主服务器发送的写数据并不一定会被从服务器接收到， 因此， 数据丢失的可能性仍然是存在的。</p>
<p>以下是这个特性的运作原理：</p>
<ul>
<li>从服务器以每秒一次的频率 PING 主服务器一次， 并报告复制流的处理情况。</li>
<li>主服务器会记录各个从服务器最后一次向它发送 PING 的时间。</li>
<li>用户可以通过配置， 指定网络延迟的最大值 min-slaves-max-lag ， 以及执行写操作所需的至少从服务器数量 min-slaves-to-write 。</li>
</ul>
<p>如果至少有 min-slaves-to-write 个从服务器， 并且这些服务器的延迟值都少于 min-slaves-max-lag 秒， 那么主服务器就会执行客户端请求的写操作。</p>
<p>另一方面， 如果条件达不到 min-slaves-to-write 和 min-slaves-max-lag 所指定的条件， 那么写操作就不会被执行， 主服务器会向请求执行写操作的客户端返回一个错误。</p>
<p>以下是这个特性的两个选项和它们所需的参数：</p>
<p>min-slaves-to-write &lt; number of slaves &gt;<br>
min-slaves-max-lag &lt; number of seconds &gt;</p>
<h2 id="Redis-sentinel-哨兵">Redis-sentinel( 哨兵)</h2>
<p>Redis 的 Sentinel 系统用于管理多个 Redis 服务器，该系统执行以下三个任务：</p>
<ul>
<li>监控（Monitoring）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</li>
<li>提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时，Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li>
<li>自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为新主服务器的从服务器； 当客户端试图连接失效的主服务器时，集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效的主服务器。</li>
</ul>
<p>Redis Sentinel 是一个分布式系统， 你可以在一个架构中运行多个 Sentinel 进程， 这些进程使用流言协议（gossipprotocols) 来接收关于主服务器是否下线的信息， 并使用投票协议（agreement protocols）来决定是否执行自动故障迁移，以及选择哪个从服务器作为新的主服务器。</p>
<p>虽然 Redis Sentinel 释出为一个单独的可执行文件 redis-sentinel ， 但实际上它只是一个运行在特殊模式下的 Redis 服务器， 你可以在启动一个普通 Redis 服务器时通过给定 --sentinel 选项来启动 Redis Sentinel 。</p>
<p><strong>启动 Sentinel</strong></p>
<p>对于 redis-sentinel 程序， 可以用以下命令来启动Sentinel 系统：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-sentinel /path/sentinel.conf</span><br></pre></td></tr></table></figure>
<p>对于 redis-server 程序， 你可以用以下命令来启动一个运行在 Sentinel 模式下的 Redis 服务器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-server /path/sentinel.conf  --sentinel</span><br></pre></td></tr></table></figure>
<p>两种方法都可以启动一个 Sentinel 实例。</p>
<p>启动 Sentinel 实例必须指定相应的配置文件， 系统会使用配置文件来保存 Sentinel 的当前状态， 并在 Sentinel 重启时通过载入配置文件来进行状态还原。如果启动 Sentinel 时没有指定相应的配置文件， 或者指定的配置文件不可写（not writable）， 那么 Sentinel 会拒绝启动。</p>
<p><strong>配置 Sentinel</strong></p>
<p>Redis 源码中包含了一个名为 sentinel.conf 的文件，这个文件是一个带有详细注释的 Sentinel 配置文件示例。</p>
<p>运行一个 Sentinel 所需的最少配置如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 制定了 Sentinel 去监视的主服务器名称、IP、端口、Sentinel投票个数</span></span><br><span class="line">sentinel monitor mymaster 192.168.110.4 6379 2</span><br><span class="line"><span class="comment"># 指定了 Sentinel 认为服务器已经断线所需的毫秒数</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"><span class="comment"># 故障迁移的时间，默认180s</span></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"><span class="comment"># 指定了在执行故障转移时，最多可以有多少个从服务器同时对新的主服务器进行同步</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"><span class="comment"># 主服务器无密码时，关闭保护模式或者配上本机ip</span></span><br><span class="line">protected-mode no / <span class="built_in">bind</span>  本机</span><br></pre></td></tr></table></figure>
<p>注意：主服务器无密码时，记得在 sentinel 配置里配上 bind 本机 ip ，或者关掉保护模式 protected-mode no</p>
<p>第一行配置指示 Sentinel 去监视一个名为 mymaster 的主服务器， 这个主服务器的 IP 地址为 127.0.0.1 ， 端口<br>
号为 6379 ， 而将这个主服务器判断为失效至少需要 2 个Sentinel 同意 （只要同意 Sentinel 的数量不达标，自动故障迁移就不会执行）。</p>
<p>不过要注意， 无论你设置要多少个 Sentinel 同意才能判断一个服务器失效， 一个 Sentinel 都需要获得系统中多数（majority） Sentinel 的支持， 才能发起一次自动故障迁移。换句话说， 在只有少数（minority） Sentinel 进程正常运作的情况下， Sentinel 是不能执行自动故障迁移的。</p>
<p>其他选项的基本格式如下：</p>
<p>sentinel &lt;选项的名字&gt; &lt;主服务器的名字&gt; &lt;选项的值&gt;</p>
<p>各个选项的功能如下：</p>
<ul>
<li>down-after-milliseconds 选项指定了 Sentinel 认为服务器已经断线所需的毫秒数。如果服务器在给定的毫秒数之内， 没有返回 Sentinel 发送的 PING 命令的回复， 或者返回一个错误， 那么 Sentinel 将这个服务器标记为主观下线（subjectively down，简称 SDOWN ）。不过只有一个 Sentinel 将服务器标记为主观下线并不一定会引起服务器的自动故障迁移： 只有在足够数量的 Sentinel 都将一个服务器标记为主观下线之后， 服务器才会被标记为客观下线，这时自动故障迁移才会执行。将服务器标记为客观下线所需的 Sentinel 数量由对主服务器的配置决定。</li>
<li>parallel-syncs 选项指定了在执行故障转移时， 最多可以有多少个从服务器同时对新的主服务器进行同步， 这个数字越小， 完成故障转移所需的时间就越长。如果从服务器被设置为允许使用过期数据集（参见对 redis.conf 文件中对 slave-serve-stale-data 选项的说明），那么你可能不希望所有从服务器都在同一时间向新的主服务器发送同步请求， <code>因为尽管复制过程的绝大部分步骤都不会阻塞从服务器， 但从服务器在载入主服务器发来的 RDB 文件时， 仍然会造成从服务器在一段时间内不能处理命令请求： 如果全部从服务器一起对新的主服务器进行同步， 那么就可能会造成所有从服务器在短时间内全部不可用的情况出现。你可以通过将这个值设为 1 来保证每次只有一个从服务器处于不能处理命令请求的状态。</code></li>
</ul>
<p><strong>测试效果：</strong></p>
<p>1、3台服务器已经都安装好Redis，并且做好主从复制。</p>
<p>2、分别在3台服务器中redis安装包中新建文件 mysentinel.conf，填入如上的 Sentinel 配置。</p>
<p>这里注意：守护进程一定要关掉。（3台都关）</p>
<p><img src="https://seanxia.oss-cn-shanghai.aliyuncs.com/img/hexo/7308598bgy1g069n1w4whj209502qmx0.jpg" alt></p>
<p>3、分别启动3台服务器的redis-server，以及redis-sentinel。</p>
<p>4、关掉主服务器，查看其它服务的监听状态。</p>
<p>会发现30秒后，哨兵sentinel会重新选举新的master</p>
<p><img src="https://seanxia.oss-cn-shanghai.aliyuncs.com/img/hexo/7308598bgy1g06an04a4vj20g402zweh.jpg" alt></p>
<p>192.168.110.5节点成为新的master。</p>
<p><code>注意：如果重新启动之前的主节点 192.168.110.4，那它依旧是slave，无法还原到master！</code></p>
<h2 id="Redis集群">Redis集群</h2>
<h3 id="集群简介">集群简介</h3>
<p>Redis 集群可以在多个 Redis 节点之间进行数据共享。</p>
<p>Redis 集群不支持那些需要同时处理多个键的 Redis 命令，因为执行这些命令需要在多个 Redis 节点之间移动数据， 并且在高负载的情况下， 这些命令将降低 Redis 集群的性能， 并导致不可预测的行为。比如：有 name1 和 name2 两个节点，命令 del name1 name2 要同时删除这个 key，就不能写在一起，得分开写。</p>
<p>Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p>
<p><strong>Redis 集群提供了以下两个好处：</strong></p>
<ul>
<li>将数据自动切分（split）到多个节点的能力。</li>
<li>当集群中的一部分节点失效或者无法进行通讯时， 仍然可以继续处理命令请求的能力。</li>
</ul>
<h3 id="集群数据共享">集群数据共享</h3>
<p>Redis 集群使用**数据分片（sharding）**而非一致性哈希来实现： 一个 Redis 集群包含 16384 个哈希槽（hash slot），数据库中的每个键都属于这 16384 个哈希槽的其中一个， 集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16校验和 。</p>
<p>集群中的每个节点负责处理一部分哈希槽。 举个例子， 一个集群可以有三个哈希槽， 其中</p>
<ul>
<li>节点 A 负责处理 0 号至 5500 号哈希槽。</li>
<li>节点 B 负责处理 5501 号至 11000 号哈希槽。</li>
<li>节点 C 负责处理 11001 号至 16384 号哈希槽。</li>
</ul>
<p>这种将哈希槽分布到不同节点的做法使得用户可以很容易地向集群中添加或者删除节点。 比如说：</p>
<ul>
<li>如果用户将新节点 D 添加到集群中， 那么集群只需要将节点A 、B 、 C 中的某些槽移动到节点 D 就可以了。</li>
<li>与此类似， 如果用户要从集群中移除节点 A ， 那么集群只需要将节点 A 中的所有哈希槽移动到节点 B 和节点 C ， 然后再移除空白（不包含任何哈希槽）的节点 A 就可以了。</li>
</ul>
<blockquote>
<p>因为将一个哈希槽从一个节点移动到另一个节点不会造成节点阻塞， 所以无论是添加新节点还是移除已存在节点， 又或者改变某个节点包含的哈希槽数量， 都不会造成集群下线。</p>
</blockquote>
<h3 id="集群的主从复制">集群的主从复制</h3>
<p>为了使得集群在一部分节点下线或者无法与集群的大多数节点进行通讯的情况下， 仍然可以正常运作， Redis 集群对节点使用了主从复制功能： 集群中的每个节点都有 1 个至 N 个复制品，其中一个复制品为主节点， 而其余的 N-1 个复制品为从节点。</p>
<p>在之前列举的节点 A 、B 、C 的例子中， 如果节点 B 下线了， 那么集群将无法正常运行， 因为集群找不到节点来处理 5501 号至 11000 号的哈希槽。</p>
<p>另一方面， 假如在创建集群的时候（或者至少在节点 B 下线之前）， 我们为主节点 B 添加了从节点 B1 ， 那么当主节点 B 下线的时候， 集群就会将 B1 设置为新的主节点， 并让它代替下线的主节点 B ， 继续处理 5501 号至 11000 号的哈希槽， 这样集群就不会因为主节点 B 的下线而无法正常运作了。</p>
<p><code>不过如果节点 B 和 B1 都下线的话， Redis 集群还是会停止运作。</code></p>
<h3 id="集群的一致性保证">集群的一致性保证</h3>
<p>Redis 集群不保证数据的强一致性（strong consistency）：在特定条件下， Redis 集群可能会丢失已经被执行过的写命令。</p>
<p>使用异步复制是 Redis 集群可能会丢失写命令的其中一个原因。 考虑以下这个写命令的例子：</p>
<ul>
<li>客户端向主节点 B 发送一条写命令。</li>
<li>主节点 B 执行写命令，并向客户端返回命令回复。</li>
<li>主节点 B 将刚刚执行的写命令复制给它的从节点 B1 、 B2 和B3 。</li>
</ul>
<p>如你所见， 主节点对命令的复制工作发生在返回命令回复之后， 因为如果每次处理命令请求都需要等待复制操作完成的话， 那么主节点处理命令请求的速度将极大地降低 —— 我们必须在性能和一致性之间做出权衡。</p>
<p>Redis 集群另外一种可能会丢失命令的情况是， 集群出现网络分裂（network partition）， 并且一个客户端与至少包括一个主节点在内的少数（minority）实例被孤立。</p>
<blockquote>
<p>举个例子， 假设集群包含 A 、 B 、 C 、 A1 、 B1 、 C1六个节点， 其中 A 、B 、C 为主节点， 而 A1 、B1 、C1 分别为三个主节点的从节点， 另外还有一个客户端 Z1 。<br>
假设集群中发生网络分裂， 那么集群可能会分裂为两方，大多数（majority）的一方包含节点 A 、C 、A1 、B1 和C1 ， 而少数（minority）的一方则包含节点 B 和客户端Z1 。</p>
<p>在网络分裂期间， 主节点 B 仍然会接受 Z1 发送的写命令：</p>
<ul>
<li>如果网络分裂出现的时间很短， 那么集群会继续正常运行；</li>
<li>但是， 如果网络分裂出现的时间足够长， 使得大多数一方将从节点 B1 设置为新的主节点， 并使用 B1 来代替原来的主节点 B ，那么 Z1 发送给主节点 B 的写命令将丢失。</li>
</ul>
<p>注意， 在网络分裂出现期间， 客户端 Z1 可以向主节点 B发送写命令的最大时间是有限制的， 这一时间限制称为节点超时时间（node timeout）， 是 Redis 集群的一个重要的配置选项：</p>
<ul>
<li>对于大多数一方来说， 如果一个主节点未能在节点超时时间所设定的时限内重新联系上集群， 那么集群会将这个主节点视为下线， 并使用从节点来代替这个主节点继续工作。</li>
<li>对于少数一方， 如果一个主节点未能在节点超时时间所设定的时限内重新联系上集群， 那么它将停止处理写命令， 并向客户端报告错误。</li>
</ul>
</blockquote>
<h3 id="集群搭建">集群搭建</h3>
<p>要让集群正常运作至少需要 3 个主节点， 不过在刚开始试用集群功能时， 强烈建议使用六个节点： 其中三个为主节点，而其余三个则是各个主节点的从节点。</p>
<p><strong>1、集群规划：</strong></p>
<p>3 个主节点，3 个从节点。</p>
<p><strong>2、新建配置文件（3台都要）</strong></p>
<ul>
<li>
<p>在redis安装包中新建文件夹 redis-cluster</p>
</li>
<li>
<p>在 redis-cluster 中新建分别以端口7000和7001命名新建两个文件夹</p>
</li>
<li>
<p>分别在7000和7001两个文件夹中新建配置文件 redis.conf（端口号要与文件夹对应）</p>
</li>
</ul>
<p>配置文件 redis.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">port 7000/7001</span><br><span class="line">cluster-enabled <span class="built_in">yes</span></span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">appendonly <span class="built_in">yes</span></span><br><span class="line">daemonize <span class="built_in">yes</span></span><br><span class="line">protected-mode no</span><br></pre></td></tr></table></figure>
<p><strong>3、启动 redis 服务</strong></p>
<p>在每台机器的 7000 和 7001 文件夹下，使用命令 <code>redis-server redis.conf</code> 启动实例</p>
<p><strong>4、安装 ruby 相关的程序</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install ruby</span><br><span class="line">yum install rubygems</span><br><span class="line">gem install redis-3.2.1.gem</span><br></pre></td></tr></table></figure>
<p><strong>5、执行命令创建集群</strong></p>
<p>在主服务器 redis 的安装包的 src 目录下执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./redis-trib.rb create --replicas 1 ip1:7000 ip1:7001 Ip2:7000 ip2:7001 ip3:7000 ip3:7001</span><br></pre></td></tr></table></figure>
<p><img src="https://seanxia.oss-cn-shanghai.aliyuncs.com/img/hexo/7308598bgy1g07c5uv4wcj20gq0ahdgg.jpg" alt></p>
<p>可以看到，集群为每个节点分配了相应的插槽。输入 yes 即可完成集群搭建。</p>
<p><strong>6、测试结果</strong></p>
<p>输入命令：redis-cli，发现无法连接</p>
<p><img src="https://seanxia.oss-cn-shanghai.aliyuncs.com/img/hexo/7308598bgy1g07cbv59t1j20gr02pmx1.jpg" alt></p>
<p>这是因为 redis 客户端默认的连接端口是 6379，但现在集群用的是 7000 和 7001</p>
<p>所以我们加上端口，如：redis-cli -p 7000</p>
<p>但是当我们给 redis 设置值的时候会发现有的值会报错</p>
<p><img src="https://seanxia.oss-cn-shanghai.aliyuncs.com/img/hexo/7308598bgy1g07cgi1zrvj20eh03xq2t.jpg" alt></p>
<blockquote>
<p>由图中可以看出 name 这个 key 被移动到了 ip 为192.168.110.5的节点上，这是因为 name 在进行 hash 之后取到的插槽值就处于192.168.110.5这个节点。</p>
</blockquote>
<p>所以我们可以到192.168.110.5这个节点去设置 key 为 name 的值。</p>
<p>但是这样切来切去有没有觉得很麻烦。Redis为我们提供了一种可以自动进行切换节点的方法，只需要在连接客户端时加上参数：-c</p>
<p><img src="https://seanxia.oss-cn-shanghai.aliyuncs.com/img/hexo/7308598bgy1g07cmww8azj20g7039jr9.jpg" alt></p>
<p>我们会发现节点自动切换到了192.168.110.5这个节点上，是不是很方便！</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://www.seanxia.cn">SeanXia</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://www.seanxia.cn/%E5%A4%A7%E6%95%B0%E6%8D%AE/890ab287.html">http://www.seanxia.cn/%E5%A4%A7%E6%95%B0%E6%8D%AE/890ab287.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external nofollow noopener noreferrer">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.seanxia.cn" target="_blank">风雨欲来兮丶</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%86%85%E5%AD%98/">内存</a><a class="post-meta__tags" href="/tags/redis/">redis</a></div><div class="post_share"><div class="social-share" data-image="https://seanxia.oss-cn-shanghai.aliyuncs.com/img/hexo/headpic.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赏一个</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://seanxia.oss-cn-shanghai.aliyuncs.com/img/hexo/%E5%BE%AE%E4%BF%A110%E5%85%83%E8%B5%9E%E8%B5%8F%E7%A0%81.jpg" target="_blank" rel="external nofollow noopener noreferrer"><img class="post-qr-code-img" src="https://seanxia.oss-cn-shanghai.aliyuncs.com/img/hexo/%E5%BE%AE%E4%BF%A110%E5%85%83%E8%B5%9E%E8%B5%8F%E7%A0%81.jpg" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://seanxia.oss-cn-shanghai.aliyuncs.com/img/hexo/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE%E7%A0%81.jpg" target="_blank" rel="external nofollow noopener noreferrer"><img class="post-qr-code-img" src="https://seanxia.oss-cn-shanghai.aliyuncs.com/img/hexo/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE%E7%A0%81.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/%E5%A4%A7%E6%95%B0%E6%8D%AE/dd52d826.html" title="Scala编程语言"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Scala编程语言</div></div></a></div><div class="next-post pull-right"><a href="/%E5%A4%A7%E6%95%B0%E6%8D%AE/53bfabca.html" title="关于ElasticSearch的优化方案"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">关于ElasticSearch的优化方案</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/Java/3474f33d.html" title="Java中的内存分析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2016-09-08</div><div class="title">Java中的内存分析</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://seanxia.oss-cn-shanghai.aliyuncs.com/img/hexo/headpic.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">SeanXia</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">43</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">72</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" href="https://github.com/Sdreamery" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Sdreamery" target="_blank" title="Github" rel="external nofollow noopener noreferrer"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:sean.xs@foxmail.com" target="_blank" title="Email" rel="external nofollow noopener noreferrer"><i class="fas fa-envelope" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">Redis的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-number">2.</span> <span class="toc-text">Redis的安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">Redis的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">3.1.</span> <span class="toc-text">切换数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Key%E6%93%8D%E4%BD%9C"><span class="toc-number">3.2.</span> <span class="toc-text">Key操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E6%93%8D%E4%BD%9C"><span class="toc-number">3.3.</span> <span class="toc-text">String操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E6%93%8D%E4%BD%9C"><span class="toc-number">3.4.</span> <span class="toc-text">List操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set%E6%93%8D%E4%BD%9C"><span class="toc-number">3.5.</span> <span class="toc-text">Set操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sorted-set-%E6%93%8D%E4%BD%9C"><span class="toc-number">3.6.</span> <span class="toc-text">Sorted set  操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash%E6%93%8D%E4%BD%9C%EF%BC%88%E6%95%A3%E5%88%97%EF%BC%89"><span class="toc-number">3.7.</span> <span class="toc-text">Hash操作（散列）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">4.</span> <span class="toc-text">Redis的持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB-Redis-DataBase"><span class="toc-number">4.1.</span> <span class="toc-text">RDB(Redis DataBase)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF-Append-Only-File"><span class="toc-number">4.2.</span> <span class="toc-text">AOF(Append Only File)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">5.</span> <span class="toc-text">Redis主从复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-sentinel-%E5%93%A8%E5%85%B5"><span class="toc-number">6.</span> <span class="toc-text">Redis-sentinel( 哨兵)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E9%9B%86%E7%BE%A4"><span class="toc-number">7.</span> <span class="toc-text">Redis集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E7%AE%80%E4%BB%8B"><span class="toc-number">7.1.</span> <span class="toc-text">集群简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB"><span class="toc-number">7.2.</span> <span class="toc-text">集群数据共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">7.3.</span> <span class="toc-text">集群的主从复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E4%BF%9D%E8%AF%81"><span class="toc-number">7.4.</span> <span class="toc-text">集群的一致性保证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA"><span class="toc-number">7.5.</span> <span class="toc-text">集群搭建</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/%E5%85%B6%E4%BB%96/6d60df94.html" title="使用Git系统搭建GitLab">使用Git系统搭建GitLab</a><time datetime="2019-08-23T16:00:00.000Z" title="发表于 2019-08-24 00:00:00">2019-08-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/%E5%85%B6%E4%BB%96/7fb68dad.html" title="新浪微博图床迁移">新浪微博图床迁移</a><time datetime="2019-08-10T16:00:00.000Z" title="发表于 2019-08-11 00:00:00">2019-08-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/%E5%A4%A7%E6%95%B0%E6%8D%AE/31afedf9.html" title="流式框架Flink（一）">流式框架Flink（一）</a><time datetime="2019-01-01T16:00:00.000Z" title="发表于 2019-01-02 00:00:00">2019-01-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/%E5%A4%A7%E6%95%B0%E6%8D%AE/1b90121.html" title="流式框架Flink（二）">流式框架Flink（二）</a><time datetime="2019-01-01T16:00:00.000Z" title="发表于 2019-01-02 00:00:00">2019-01-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/%E5%A4%A7%E6%95%B0%E6%8D%AE/1ca1f555.html" title="SparkMLlib 随机森林">SparkMLlib 随机森林</a><time datetime="2018-05-21T16:00:00.000Z" title="发表于 2018-05-22 00:00:00">2018-05-22</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://seanxia.oss-cn-shanghai.aliyuncs.com/img/hexo/butterfly.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By SeanXia</div><div class="framework-info"><span>框架 </span><a href="https://hexo.io" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" rel="external nofollow noopener noreferrer" target="_blank">Butterfly</a></div><div class="footer_custom_text"><a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" rel="external nofollow noopener noreferrer" target="_blank"><span>本网站由</span><img class="icp-icon" src="https://seanxia.oss-cn-shanghai.aliyuncs.com/img/hexo/%E5%8F%88%E6%8B%8D%E4%BA%91_logo5.png"><span>提供 CSDN 加速/云存储服务</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>(() => {
  const initGitalk = () => {
    const gitalk = new Gitalk(Object.assign({
      clientID: '6426e1d3285a84ce7134',
      clientSecret: '30e13e4623fd734097033c1edb8c8af6934f5c88',
      repo: 'Sdreamery.github.io',
      owner: 'Sdreamery',
      admin: ['Sdreamery'],
      id: '18d1e33578ebe01758ed0ac6ec9666b1',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async() => {
    if (typeof Gitalk === 'function') initGitalk()
    else {
      await getCSS('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.css')
      await getScript('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js')
      initGitalk()
    }
  }
  
  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="true" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>